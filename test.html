<p>One in every 5 people in the world has a smartphone in their pocket. In a world where everyone has access to camera phone, mobile photography has become the every day norm, and with that, the mobile photo app market has blown up. There are whole categories dedicated to them the Apple App Store and Google Play stores. Consumers have also come to expect, at the very least, a simple photo editing solution in their mobile photo apps. That&#8217;s where Aviary comes in. </p>

<p>Aviary is a simple, yet powerful photo editing engine that powers more than 6,000 mobile applications and websites. The standard Aviary offering is a customizable widget, with powerful tools such as brightness, saturation, teeth whitening, redeye reduction, as well as photo filters, stickers and frame overlays. Aviary&#8217;s mobile SDK&#8217;s are all native code, and all of the rendering happens locally on the device. Our web widget is written in Javascript and the image rendering for images up to 1 megapixel happens right in the browser. For high resolution photo editing on the web, the widget communicates with the Aviary Render farm to replay the user&#8217;s edits on the full resolution photo.</p>

<p>Now you&#8217;re probably wondering how a communications API like Twilio can interface with a photo editor API like Aviary? Well to start, you&#8217;ve probably heard that Twilio has recently released support for MMS. That means that you can now text photos directly to a server endpoint. As I previously mentioned, Aviary has a server-side Render Farm for full resolution image editing on the web. Until recently, we&#8217;ve maintained this service exclusively to augment the web widget.</p>

<p>In this tutorial, I&#8217;ll show you how to bypass the Aviary web widget entirely, and how to communicate directly with the our server-side rendering endpoint for editing photos programatically. For the purposes of this tutorial, we&#8217;ll be creating a simple server endpoint that accepts a photo url via SMS, and responds with a url to an edited photo. In the future, this can easily be extended to accept and respond to MMS messages.</p>

<p>To start, let&#8217;s take a high level look at how the Aviary web widget communicates with the Rendering endpoint. </p>

<h2>Aviary Overview</h2>

<p>As a user edits their photo in the web widget, each time they &#8216;apply&#8217; an operation it&#8217;s stored in a JSON &#8220;actionlist&#8221;. This actionlist can be exported using the <code>getActionList()</code> method on the Aviary web widget object (see full web <a href="#">documentation</a> for more details). When the <code>saveHiRes()</code> method is called, this actionlist is posted to a server endpoint (<code>/render</code>) along with a url point at the high resultion photo that the developer had provided when launching the editor. The editor then polls a second endpoint (<code>/render/{jobId}</code>) until the photo has finished rendering. At this point, the <code>onSaveHiRes(id, url)</code> callback is called, and the developer has access to the full resolution photo.</p>

<p>Now let&#8217;s take a deeper look at these two endpoints, and we can communicate with them directly using the Aviary node.js wrapper.</p>

<h2>Authentication</h2>

<p>To start, every request to the Aviary server-side API must be acompanied by a <code>signature</code> that&#8217;s genearted using your <code>apikey</code>, <code>secret</code>, a <code>timestamp</code> and a unique <code>salt</code>. Signature generation is fairly straighforward and the node.js wrapper abstracts it away for you entirely. You&#8217;ll still need to privde your apikey and secret, which you can get by creating an account at <a href="http://www.aviary.com/developers">aviary.com/developers</a> and creating a new web app. Your key will need to be whitelisted, so if you want to use this functionality in your own application, you&#8217;ll need to contact us at <a href="mailto:partners+twilio@aviary.com">partners+twilio@aviary.com</a>. </p>

<h2>ActionList</h2>

<p>Now that you have your whitelisted apikey, let&#8217;s jump right into editing that photo. </p>

<p>As I mentioned above in the high level Aviary description, every render operation requires an <code>actionlist</code> that has been generated by the editor. You can generate your own actionlists by launching the editor, completing a few operations in the UI, and programatically calling the editor.getActionList() method. To make things a little easier, I&#8217;ve put together a list of actionlists that you can use in your app <a href="#">here</a>.</p>

<p>//TODO&#8230;some stipulations around aspect ratio, etc</p>

<h2>Aviary API</h2>

<p>Now that you have your <code>actionlist</code>, lets test it out with a simple node integration.</p>

<pre><code>var Aviary = require('aviary').Aviary;

var key = '';
var secret = '';
var url = '';
var actionlist = '';

var aviaryClient = new Aviary(key, secret);
aviaryClient.renderAndWait(url, actionlist, function(err, newUrl) {
    console.log(newUrl);
});
</code></pre>

<p>First thing first, we require the Aviary NPM module and include the Aviary Constructor. When you instantiate the API wrapper, you pass in your Aviary api key and secret. The wrapper will take care of the signature generation for each request.</p>

<p>When you call <code>aviaryClient.renderAndWait()</code>, the wrapper makes the initial <code>/render</code> API call, which returns a <code>jobId</code>. The method then polls the <code>/render/{jobid}</code> at 1 second intervals until a <code>JobComplete</code> status is returned along with a <code>url</code> pointing at the final rendered image - at which point, your callback is called with the new url.</p>

<p>Tada!</p>

<p>Now let&#8217;s extend this with a simple server that can accept and respond to a Twilio SMS.</p>

<h2>Twilio + Aviary App</h2>

<p>If you&#8217;re reading this, you&#8217;re probably already familiar with handling Twilio SMS&#8217;s, but for the sake of completeness I&#8217;ll give you a quick refresher. </p>

<p>When you purchase a phone number from Twilio, you can set a Messaging Request URL. Any SMS message to this number will create a POST request to this url with the message in the POST body. When you receive this request, you can respond with a TwiML formated response to send a SMS message back to the sender. Let&#8217;s take a look at what that looks like with a simple expressjs server.</p>

<h3>Step 1: Create Express Server to Respond to SMS</h3>

<pre><code>var express         = require('express'),
    app             = express();

app.use(express.bodyParser());

app.post('/incoming', function(req, res) {
    console.log(req.body.Body);

    res.writeHead(200, {'Content-Type': 'text/xml'});
    res.end(generateTwiml('Thanks for the message!'));
});

 function generateTwiml(message) {
    return ['&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;',
        '&lt;Response&gt;',
            '&lt;Message&gt;',
                message,
            '&lt;/Message&gt;',
        '&lt;/Response&gt;'
    ].join('');
}

var server = app.listen(process.env.PORT);
console.log(&quot;Listening on port %d in %s mode&quot;, server.address().port, app.settings.env);
</code></pre>

<p>The above code sample is pretty straightforward. First we create an <code>express</code> server and use the <code>bodyParser()</code> middleware to help us extract the SMS Body from the POST data. Next we create a POST handler for requests to the &#8216;/incoming&#8217; endpoint. Finally, we log the request Body to the console to verify that it&#8217;s working, and respond with an SMS message &#8220;Thanks for the message!&#8221;. Note the <code>generateTwiml()</code> helper function that we use to correctly format the message response body correctly format the response. </p>

<p>Hey, that wasn&#8217;t too tough. Now let&#8217;s tie this together with the Aviary module and get some photo filters in there.</p>

<h3>Step 2: Detect Image Url and Render with Aviary</h3>

<pre><code>var express         = require('express'),
    app             = express(),
    actionLists     = require('./actionLists.json'),
    Aviary          = require('aviary').Aviary;
    aviaryClient    = new Aviary(process.env.AVIARY_API_KEY, process.env.AVIARY_API_SECRET);

app.use(express.bodyParser());

app.post('/incoming', function(req, res) {
    var urlPattern = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?/
    var urls = urlPattern.exec(req.body.Body);

    if (urls &amp;&amp; urls.length &gt; 0) {
        aviaryClient.renderAndWait({
            url: urls[0],
            actionList: JSON.stringify(actionLists.filters.avenue)
        }, function(err, renderedUrl) {            
            res.writeHead(200, {'Content-Type': 'text/xml'});            
            if (err) {
                return res.end(generateTwiml('Oops! Something went wrong.'));
            }             
            return res.end(generateTwiml('Oooh pretty! ' + renderedUrl));
        });
    } else {
        res.writeHead(200, {'Content-Type': 'text/xml'});
        return res.end(generateTwiml('Oops! Try sending an image url.'));
    }
});

function generateTwiml(message) {
    return ['&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;',
        '&lt;Response&gt;',
            '&lt;Message&gt;',
                message,
            '&lt;/Message&gt;',
        '&lt;/Response&gt;'
        ].join('');
}

var server = app.listen(process.env.PORT);
console.log(&quot;Listening on port %d in %s mode&quot;, server.address().port, app.settings.env);
</code></pre>

<p>First let&#8217;s look at these new modules we&#8217;ve included.</p>

<pre><code>var express         = require('express'),
    app             = express(),
    actionLists     = require('./actionLists.json'),
    Aviary          = require('aviary').Aviary;
    aviaryClient    = new Aviary(process.env.AVIARY_API_KEY, process.env.AVIARY_API_SECRET);
</code></pre>

<p>If you take a look at <a href="#">actionList.json</a>, you&#8217;ll find a few pre-canned actionlists that were generated using the method described in the <strong>ActionList</strong> section above. We&#8217;ve also created an aviaryClient object that we&#8217;ll use to interact with the Aviary API.</p>

<p>Now let&#8217;s look at what we&#8217;ve done in the <code>/incoming</code> endpoint.</p>

<pre><code>app.post('/incoming', function(req, res) {
    var urlPattern = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?/
    var urls = urlPattern.exec(req.body.Body);

    if (urls &amp;&amp; urls.length &gt; 0) {
        aviaryClient.renderAndWait({
            url: urls[0],
            actionList: JSON.stringify(actionLists.filters.avenue)
        }, function(err, renderedUrl) {            
            res.writeHead(200, {'Content-Type': 'text/xml'});            
            if (err) {
                return res.end(generateTwiml('Oops! Something went wrong.'));
            }             
            return res.end(generateTwiml('Oooh pretty! ' + renderedUrl));
        });
    } else {
        res.writeHead(200, {'Content-Type': 'text/xml'});
        return res.end(generateTwiml('Oops! Try sending an image url.'));
    }
});

function generateTwiml(message) {
    return ['&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;',
        '&lt;Response&gt;',
            '&lt;Message&gt;',
                message,
            '&lt;/Message&gt;',
        '&lt;/Response&gt;'
        ].join(''&quot;);
}
</code></pre>

<p>The first thing we do is extract any url&#8217;s from the SMS Body. If we were using Twilio&#8217;s MMS support, we would pull it out of the MMS&#8217;s MediaUrl, but because that would require a MMS enabled number (which for now is difficult to get), we&#8217;ll work with SMS for now. Next, if a url is found, we call <code>aviaryClient.renderAndWait()</code> and pass in the supplied <code>url</code>, a pre-canned actionlist from the <code>actionLists</code> object, and a callback for when the render job is complete. When the render callback is called, we respond with a message that contains the rendered image url. Note: if we had MMS support, we would respond with a <code>&lt;MediaUrl&gt;</code> tag, but for now, we&#8217;ll keep it all in the response body.</p>

<p>That&#8217;s it! You&#8217;ve got a working node server that can accept an incoming SMS message containing an image url, and respond with a rendered image.</p>

<p>One final note, in order to run your server, you&#8217;ll need to define some necessary environment variables:</p>

<pre><code>export AVIARY_API_KEY=xxxx
export AVIARY_API_SECRET=yyy
</code></pre>

<p>You can get your Aviary key and secret by registering an account on http://www.aviary.com/developers and creating a web app. Contact us at partners+twilio@aviary.com to whitelist your key.</p>

<p>You can find the full working example on Github.</p>

<p>If you have any questions or comments, please tweet @arifuchs or email ari@aviary.com!</p>